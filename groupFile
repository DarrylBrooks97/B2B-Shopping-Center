/**************************************************************
 *
 * GROUP #
 * Group Members:
 * Date Completed:
 * Filename: shoppingCart.cpp
 * 
 **************************************************************/

#include <iostream>
#include <ctime>
#include <sstream>
#include <vector> 
#include <fstream>
#include <cstdlib> 
#include <iomanip>
#include <string>

using namespace std;

struct Address{ 
			string streetAddress; 
			string city; 
			string state; 
			string zipCode; 
};

struct Customer{ 
	string customerNum; 
	string customerName; 
	double lineOfCredit; 
	Address * corperateAddress; 
};

struct Product{ 
	int itemNo; 
	string description; 
	double price; 
};

struct Memory{
	int position;
	int quantity;
	double cartTotal;
	double remainFunds;
};

vector<string> parse(string, char);
void readData(vector<Customer>&,vector<Address>&,vector<Product>&,Customer&,Address&,Product&);
void selectionSort(vector<Customer>&,vector<Address>&);
int binarySearch(vector<Customer>,int);
int linearSearch(vector<Customer>,string);
int linearSearchInvent(vector<Product>,int);
string upperCaseIt(string);
string generateOrderNum();
void printReceipt(vector<Customer>, vector<Address>, vector<Product>, int,int,int,int);
	
int main(){
	   Customer custObj;
	   Address  addObj;
	   Product  prodObj;
	   Memory   memObj;
	   vector<Customer> custInfo;
	   vector<Address>   custAdd;
	   vector<Product>  custProd;
	   vector<Memory>    custMem;
	   int temp,numPos,prodCode,prodPos,quantity,position;
	   string empName,cusName,option;
	   char choice,choice2;
	   double total,finalTotal;
	   double funds;
	
	  string fileName;
	  fileName=generateOrderNum();                         //Order number is generated 
	  ofstream outF;
	  outF.open(fileName.c_str());                         //Creates output file's name by order number
	   
	   
	   readData(custInfo,custAdd,custProd,custObj,addObj,prodObj);  //Loads Structs with file information 
	   selectionSort(custInfo,custAdd);                             //Sorts Customer numbers Asc->Des
	
	
	   cout<<"Has a customer placed an order? Y/N:";
	   cin>>choice;
	   
if(choice=='Y' || choice== 'y'){
		   
		cout<<"Enter Employee name: ";
	    cin>>empName;
		cout<<"Would you like to search customer by Name or Number? ";
		cin>>option;
		option=upperCaseIt(option);                                       //Fixes case sensitivity
			
			while((option!="NAME") && (option!="NUMBER")){
			cout<<"Please enter Name or Number"<<endl;
			cin>>option; 
			option = upperCaseIt(option);                                 //Fixes case sensitivity
		   }
		   if(option=="NAME"){
			   
		      cout<<"Enter customer's name: ";
	          cin>>cusName;
			  numPos = linearSearch(custInfo,cusName);                    //Searches Customer's file for correct name then returns it's position
			  
			  while(numPos==-1){                                          //Keeps asking the user for the correct customer name
			  cout<<"Name not found"<<endl;  
			  cout<<"Please try again"<<endl;
		      cout<<"Enter customer's name: ";
			  cin>>cusName;
			  numPos = linearSearch(custInfo,cusName);                    //Searches Customer's file for correct name then returns it's position
			  }
			   
		  } else if(option=="NUMBER"){
			    cout<<"Enter Customer number: ";
			    cin>>temp;
                numPos = binarySearch(custInfo,temp);                     //Searches Customer's file for correct customer number then returns it's position 
			    
			    while(numPos==-1){                                        //Keeps asking the user for the correct Customer number
					cout<<"Customer not found"<<endl;
					cout<<"Please try again"<<endl;
					cout<<"Enter Customer number: ";
					cin>>temp;
					numPos = binarySearch(custInfo,temp);                 //Searches Customer's file for correct number then returns it's position 
				}

		   }
	           funds=custInfo[numPos].lineOfCredit;                      //Sets funds to how much credit the customer has
	
	           cout<<"Would you like add a product? Y/N:";
	           cin >>choice2;
if((choice2=='Y') || (choice2=='y')){
	       while( (choice2=='Y') || (choice2=='y') ){
				  
			   
	           cout<<"Enter Product code: ";
	           cin>>prodCode;
	           prodPos=linearSearchInvent(custProd,prodCode);                 //Searches Inventory file for Item then returns it's Position
	
	           while(prodPos==-1){                                            //Keeps asking the user for the correct Product number 
					cout<<"Item not found"<<endl;
					cout<<"Please try again"<<endl;
				    cout<<"Enter Product code:";
					cin>>prodCode;
					prodPos = linearSearchInvent(custProd,prodCode);          //Searches Inventory file for Item then returns it's Position
				}
	         
	          cout<<"Enter quantity: ";                                       //Lets user enter quantity
	          cin>>quantity;     
	          memObj.position=prodPos;                                        //Records where the product is at
			  memObj.quantity=quantity;                                       //Saves quantity of product 
			  
			  memObj.cartTotal=custProd[memObj.position].price * memObj.quantity;
			  funds-=memObj.cartTotal;
			  
	          if(funds<=0){
				  cout<<"Insuffcient funds"<<endl;                            //Doesn't add the product to memory
				  funds+=memObj.cartTotal;
				  
			  } else {
				  custMem.push_back(memObj);                                  //Adds the product to memory 
			  }
			   
			   cout<<"Would you like to add another product? Y/N:";
	           cin >>choice2;
			  }
}else{
	   cout<<"Order Cancelled"<<endl; exit(0);                                      //Customer does not want to order so this ends the program
}
	  outF<<"-----------------------------------------------------------"<<endl;
	  outF<<"B2B Shopping Cart"<<endl;
	  outF<<"-----------------------------------------------------------"<<endl;
	  outF<<"Order Number: "<<fileName<<endl;
	  outF<<"Associate: "<<empName<<endl;
	  outF<<"Customer Number: "<<custInfo[numPos].customerNum<<endl;
	  outF<<"Customer: "<<custInfo[numPos].customerName<<endl;
	  outF<<"Address: "<<custAdd[numPos].streetAddress<<" |"<<endl;
	  outF<<custAdd[numPos].city<<", "<<custAdd[numPos].state<<" "<<custAdd[numPos].zipCode;
	  outF<<endl;
	  outF<<"-----------------------------------------------------------"<<endl;
	  outF<<"Item No"<<setw(18)<<"Description"<<setw(19)<<"Qty"<<setw(15)<<"Total"<<endl;
	  outF<<"-----------------------------------------------------------"<<endl;
	  
	  for(int k=0;k<custMem.size();k++){
		  position=custMem[k].position;
		  finalTotal+=custMem[k].cartTotal;
		  outF<<custProd[position].itemNo<<setw(33)<<custProd[position].description;
		  outF<<setw(7)<<custMem[k].quantity<<setw(15)<<"$"<<custMem[k].cartTotal<<endl;
	  }
	  outF<<"-----------------------------------------------------------"<<endl;
	  outF<<"Total"<<setw(54)<<"$"<<finalTotal<<endl;
	  outF<<"Remaining Credit"<<setw(43)<<"$"<<funds<<endl;    
          
} else {
		   cout<<"Have a nice day"<<endl;
	   }
	
	
	outF.close();
	return 0;
}


void readData(vector<Customer>&addCust,vector<Address>&cAdd,vector<Product>&pAdd,Customer&add,Address&street,Product& product){
	vector<string> custInfo;
	vector<string> custAddress;
	vector<string> custProduct;
	ifstream file,stock;
	file.open("customers.dat");
	stock.open("Inventory.dat");
    string line,location,inventory;
	
	while(file) {
		
		getline(file,line);                           //Gets full lines from customers.dat file
		custInfo=parse(line,'|');                     //Parse's "line" until it reaches '|'
        
		
		add.customerNum=custInfo[0];                  //Adds 1st parse to the Struct member 
		add.customerName=custInfo[1];                 //Adds 2nd parse to the Struct member 
		add.lineOfCredit=atof(custInfo[2].c_str());   //Needed to convert from string to double then places into Struct member 
		location=custInfo[3];                         //Adds 3rd parse to a new string so we can parse that string for the Address struct 
		
		custAddress=parse(location,',');              //Parse the location to go into Address struct
		
		street.streetAddress=custAddress[0];          //Adds 1st parse to the Struct member 
		street.city=custAddress[1];                   //Adds 2nd parse to the Struct member 
		street.state=custAddress[2];                  //Adds 3rd parse to the Struct member 
		street.zipCode=custAddress[3];                //Adds 4th parse to the Struct member 
		
		add.corperateAddress=&street;                 //Object points to another Address
		
		getline(stock,inventory);                      //Gets full lines from inventory.dat file
		custProduct=parse(inventory,',');              //Parse the inventory to go into Product struct
		
		product.itemNo=atoi(custProduct[0].c_str());  //Needed to convert from string to int 
		product.description=custProduct[1];
		product.price=atof(custProduct[2].c_str());   //Needed to convert from string to double
		
		addCust.push_back(add);                       //Adding objects into Customer stuct
		cAdd.push_back(street);                       //Adding objects into Address  struct
		pAdd.push_back(product);                      //Adding objects into Product  struct 
	}
	
	file.close();                                     //Closes Customers file
	stock.close();                                    //Closes Inventory file 
}

void selectionSort(vector<Customer>&cVector,vector<Address>&aVector){     //Sorts the customer vector by customer number
	
	int minPos;
	string minNum,minName;
	Address *minAdd;
	double minCred;
	
	for(int i=0;i<cVector.size();i++){
		minPos=i;
		minNum=cVector[i].customerNum;
		minName=cVector[i].customerName;
		minCred=cVector[i].lineOfCredit;
		minAdd=cVector[i].corperateAddress;
		
		for(int k=i;k<cVector.size();k++){
			if(cVector[minPos].customerNum>cVector[k].customerNum){
				minPos=k;
				minNum=cVector[k].customerNum;  
				minName=cVector[k].customerName;
				minCred=cVector[k].lineOfCredit;
				minAdd=cVector[k].corperateAddress;
				
				
			}
		}
		cVector[minPos].customerNum=cVector[i].customerNum;
		cVector[minPos].customerName=cVector[i].customerName;
		cVector[minPos].lineOfCredit=cVector[i].lineOfCredit;
		cVector[minPos].corperateAddress=cVector[i].corperateAddress;
		
		cVector[i].customerNum=minNum;
		cVector[i].customerName=minName;
		cVector[i].lineOfCredit=minCred;
		cVector[i].corperateAddress=&minAdd[minPos];
	}
}

int binarySearch(vector<Customer> cVector,int customerNum){   //Searches customer objects for correct customer number 
	int lo=0,mid,hi=cVector.size()-1,temp;
	bool state=false;
	
	while(lo<hi){
		mid=(lo+hi)/2;
		
		if(customerNum==atoi(cVector[mid].customerNum.c_str())){
			state=true;return mid;break;
		}else if(customerNum>atoi(cVector[mid].customerNum.c_str())){
			lo=mid+1;
		}else{
			hi=mid-1;
		}
	}
	if(state==false) return -1;
} 

int linearSearch(vector<Customer> cVector,string name){       //Searches customer objects for correct name
	
	int pos=0;
	string nameObj,nameSearch;
	for(int i=0;i<cVector.size();i++){
		
		nameObj=upperCaseIt(cVector[i].customerName);    //Fixes case sensitivity
		nameSearch=upperCaseIt(name);                    //Fixes case sensitivity
		
		if(nameObj==nameSearch) pos=i;                   //If both names are equal then hold that position 
		
	}
	
	if(pos!=-1) return pos;                              //Sends position of name 
	else return -1;
}     

int linearSearchInvent(vector<Product> cVector,int code){     //Searches inventory objects for correct product numbers 
	
	int pos=-1;
	for(int i=0;i<cVector.size();i++){
		if(cVector[i].itemNo==code) pos=i;                    //If both numbers are equal then hold that position 
	}
	
	if(pos!=-1) return pos;                                  //Sends position of name 
	else return -1;
} 

/**************************************************************
 *                             Parse                          *
 * Called by: <fill in>                                       *
 * Passed   : 2 arguments: a string, a character that is the  *
 *            delimiter                                       *
 * Purpose  : Split a given string by its delimiter           *
 * Returns  : String vector                                   *
 **************************************************************/
vector<string> parse(string line, char delimiter){
    
    vector<string> parsedLine;
    istringstream stringStream( line ); //create string stream from the line
    //iterate through the stream
    while (stringStream)
    {
        string s;
        //uses getline to get the values from the stream before the delimiting character
        if (getline( stringStream, s, delimiter))
          parsedLine.push_back(s);
    }
    return parsedLine;
}


/**************************************************************
 *                  generateOrderNum                          *
 * Called by: <fill in>                                       *                                    
 * Purpose  : Generate an order number based on epoch         *
 * Returns  : String order number                             *
 **************************************************************/

string generateOrderNum(){
    
    time_t now = time(0); //current time object
    
    string oNum;
    stringstream strstream;
    
    strstream << now; //read the date/time in epoch into the string stream
    strstream >> oNum; //output a string from the string stream
    return oNum;
}

string upperCaseIt(string stringIn)         //Used to fix case sensitivity
{  
    string upperCase;
    
    for(int i=0;i<stringIn.length();i++)
    {
      upperCase += toupper(stringIn[i]);
    } 
    
  return upperCase;
}

